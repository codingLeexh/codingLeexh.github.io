<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java面试宝典2017版---第一篇]]></title>
    <url>%2F2018%2F02%2F12%2F2018%2FJava%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8%E6%91%98%E8%A6%81%2FJava%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[吾爱有三，日，月，卿；日为朝，月为暮，卿为朝朝暮暮。 12018年，从心开始。 1.Java基础1.一个”.java”源文件中是否可以包括多个类（不是内部类）？有什么限制？ 答：可以有多个类，但只能有一个public的类，并且public的类名必须与文件名相一致。 123456789101112131415解析：public class test &#123; public class testC&#123; &#125;&#125;class testA&#123; &#125;class testB&#123; &#125; 这是一个正确的类文件。如果给类testA或者testB加上public则会报错，原因：一个.java源文件中只能有一个public的类（不是内部类）。 内部类：testC为内部类。 2.Java有没有goto? 答：Java中的保留字，现在没有在Java中使用。 1234解析：什么是goto？ goto 是汇编语言的程序控制结构的始祖：“若条件A，则跳到这里；否则跳到那里”。 goto是一条可以在许多计算机编程语言中找到的语句。它是英文单词go和to的组合。当执行这条语句的时候，它将控制流程无条件地转到另一条语句（也叫“跳转”）。 跳转语句需要指明标记，在不同语言中，标记可以是标识符或行号。在机器码级别，goto是一种分支的形式。 Java中并没有使用过goto，但是Java中的break或continue关键字都是goto的形式。 3.说说&amp;和&amp;&amp;的区别 答：首先了解&amp;和&amp;&amp;，它们都可以用作逻辑与的运算符，表示逻辑与（and），当运算符两边的表达式的结果都为true时，整个运算结果才为true，否则，只要有一方为false，则结果为false。 123456789解析： &amp;&amp;：&amp;&amp;还具有短路的功能，即如果第一个表达式为false，则不再计算第二个表达式。 例如： if(str != null &amp;&amp; !str.equals(“”)) 当str为null时，后面的表达式不会执行，所以不会出现NullPointerException，如果将&amp;&amp;改为&amp;，则会抛出NullPointerException异常。 If(x==33 &amp; ++y&gt;0) y会增长，If(x==33 &amp;&amp; ++y&gt;0)不会增长 &amp;：&amp;还可以用作位运算符，当&amp;操作符两边的表达式不是boolean类型时，&amp;表示按位与操作，我们通常使用0x0f来与一个整数进行&amp;运算，来获取该整数的最低4个bit位。 例如： 0x31 &amp; 0x0f的结果为0x01。 &amp;的位运算符原理：0x31 &amp; 0x0f=0x01怎么算的？在这里，0x表示十六进制数，进行运算先转换成二进制数，0x31对应的二进制数是0011 0001；0xOf对应的是0000 1111。&amp;是按位与运算符，若是上下每列全是1那这一列的结果就是1，否则为0；经过计算可得出0000 0001；转化成十六进制就是0x01。 4.在JAVA中如何跳出当前的多重嵌套循环？ 答：在Java中，要想跳出多重循环，可以在外面的循环语句前定义一个标号，然后在里层循环体的代码中使用带有标号的break 语句，即可跳出外层循环。 123456789101112131415161718192021解析： ①.ok: for(int i=0;i&lt;10;i++) &#123; for(int j=0;j&lt;10;j++) &#123; System.out.println(“i=” + i + “,j=” + j); if(j == 5) break ok; &#125; &#125; ②.条件控制：让外层的循环条件表达式的结果可以受到里层循环体代码的控制，例如在**二维数组**中查找到某个数字 //定义二维数组 int arr[][] = &#123;&#123;1,2,3&#125;,&#123;4,5,6,7&#125;,&#123;9&#125;&#125;; boolean found = false; for(int i=0;i&lt;arr.length &amp;&amp; !found;i++) &#123; for(int j=0;j&lt;arr[i].length;j++)&#123; System.out.println(“i=” + i + “,j=” + j); if(arr[i][j] == 5) &#123; found = true; break; &#125; &#125; &#125; 二维数组？二维数组本质上是以数组作为数组元素的数组，即“数组的数组”，类型说明符 数组名[常量表达式][常量表达式]。二维数组又称为矩阵，行列数相等的矩阵称变方阵。对称矩阵a[i][j] = a[j][i]，对角矩阵：n阶方阵主对角线外都是零元素。 5.switch语句能否作用在byte上，能否作用在long上，能否作用在String上? 答：在switch（expr1）中，expr1只能是一个整数表达式或者枚举常量（更大字体），整数表达式可以是int基本类型或Integer包装类型，由于，byte,short,char都可以隐含转换为int，所以，这些类型以及这些类型的包装类型也是可以的。显然，long和String类型都不符合switch的语法规定，并且不能被隐式转换成int类型，所以，它们不能作用于swtich语句中。 12345678910解析： byte a=1; switch (a) &#123; case 1: System.out.println(&quot;switch语句能作用在byte上&quot;); break; default: break; &#125; 控制台输出“switch语句能作用在byte上”，而long和string转换int需要强制转换或者调用其它方法，例如long转int调用intVlaue()方法。 6.short s1 = 1; s1 = s1 + 1;有什么错? short s1 = 1; s1 += 1;有什么错? 答： 对于short s1 = 1; s1 = s1 + 1; 由于s1+1运算时会自动提升表达式的类型，所以结果是int型，再赋值给short类型s1时，编译器将报告需要强制转换类型的错误。 对于short s1 = 1; s1 += 1;由于 += 是java语言规定的运算符，java编译器会对它进行特殊处理，因此可以正确编译。 盘点Java中+=；s1+=1相当于s1=s1+1，等式是先将1转换为s1一样的类型再进行s1+1。也就等价于s1=s1+(s1)1； 7.char型变量中能不能存贮一个中文汉字?为什么? 答：char型变量是用来存储Unicode编码的字符的，unicode编码字符集中包含了汉字，所以，char型变量中当然可以存储汉字啦。不过，如果某个特殊的汉字没有被包含在unicode编码字符集中，那么，这个char型变量中就不能存储这个特殊汉字。补充说明：unicode编码占用两个字节，所以，char类型的变量也是占用两个字节。 1234567891011121314151617181920212223String str= &quot;中&quot;; char x =&apos;中&apos;; byte[] bytes=null; byte[] bytes1=null; try &#123; bytes = str.getBytes(&quot;utf-8&quot;); bytes1 = charToByte(x); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;bytes 大小：&quot;+bytes.length); System.out.println(&quot;bytes1大小：&quot;+bytes1.length); &#125; public static byte[] charToByte(char c) &#123; byte[] b = new byte[2]; b[0] = (byte) ((c &amp; 0xFF00) &gt;&gt; 8); b[1] = (byte) (c &amp; 0xFF); return b; &#125; //运行结果： //bytes 大小：3 //bytes1大小：2 unicode为2个字节（16位）来表示一个字符 8.用最有效率的方法算出2乘以8等於几? 答：2 &lt;&lt; 3 12解析： 因为将一个数左移n位，就相当于乘以了2的n次方，那么，一个数乘以8只要将其左移3位即可，而位运算cpu直接支持的，效率最高，所以，2乘以8等於几的最效率的方法是2 &lt;&lt; 3。 2&lt;&lt;3，直接读作2左移3位，而不是2小于小于3。 9.请设计一个一百亿的计算器首先要明白这道题目的考查点是什么，一是大家首先要对计算机原理的底层细节要清楚、要知道加减法的位运算原理和知道计算机中的算术运算会发生越界的情况，二是要具备一定的面向对象的设计思想。 12345678910111213141516171819202122232425262728293031323334首先，计算机中用固定数量的几个字节来存储的数值，所以计算机中能够表示的数值是有一定的范围的，为了便于讲解和理解，我们先以byte 类型的整数为例，它用1个字节进行存储，表示的最大数值范围为-128到+127。 -1在内存中对应的二进制数据为11111111，如果两个-1相加，不考虑Java运算时的类型提升，运算后会产生进位，二进制结果为1,11111110，由于进位后超过了byte类型的存储空间，所以进位部分被舍弃，即最终的结果为11111110，也就是-2，这正好利用溢位的方式实现了负数的运算。 -128在内存中对应的二进制数据为10000000，如果两个-128相加，不考虑Java运算时的类型提升，运算后会产生进位，二进制结果为1,00000000，由于进位后超过了byte类型的存储空间，所以进位部分被舍弃，即最终的结果为00000000，也就是0，这样的结果显然不是我们期望的，这说明计算机中的算术运算是会发生越界情况的，两个数值的运算结果不能超过计算机中的该类型的数值范围。 由于Java中涉及表达式运算时的类型自动提升，我们无法用byte类型来做演示这种问题和现象的实验，大家可以用下面一个使用整数做实验的例子程序体验一下： int a = Integer.MAX_VALUE; int b = Integer.MAX_VALUE; int sum = a + b; System.out.println(“a=”+a+”,b=”+b+”,sum=”+sum);先不考虑long类型，由于int的正数范围为2的31次方，表示的最大数值约等于2*1000*1000*1000，也就是20亿的大小，所以，要实现一个一百亿的计算器，我们得自己设计一个类可以用于表示很大的整数，并且提供了与另外一个整数进行加减乘除的功能，大概功能如下： （）这个类内部有两个成员变量，一个表示符号，另一个用字节数组表示数值的二进制数 （）有一个构造方法，把一个包含有多位数值的字符串转换到内部的符号和字节数组中 （）提供加减乘除的功能 public class BigInteger&#123; int sign; byte[] val; public Biginteger(String val) &#123; sign = ; val = ; &#125; public BigInteger add(BigInteger other) &#123; &#125; public BigInteger subtract(BigInteger other) &#123; &#125; public BigInteger multiply(BigInteger other)&#123; &#125; public BigInteger divide(BigInteger other)&#123; &#125; &#125; 参看jdk中自带的java.math.BigInteger类的源码 要想写出这个类的完整代码，面试的人也知道谁都不可能在短时间内写出这个类的完整代码的，他要的是你是否有这方面的概念和意识，他最重要的还是考查你的能力，所以，你不要因为自己无法写出完整的最终结果就放弃答这道题，你要做的就是你比别人写得多，证明你比别人强，你有这方面的思想意识就可以了，毕竟别人可能连题目的意思都看不懂，什么都没写，你要敢于答这道题，即使只答了一部分，那也与那些什么都不懂的人区别出来，拉开了距离，算是矮子中的高个，机会当然就属于你了。另外，答案中的框架代码也很重要，体现了一些面向对象设计的功底，特别是其中的方法命名很专业，用的英文单词很精准，这也是能力、经验、专业性、英语水平等多个方面的体现，会给人留下很好的印象，在编程能力和其他方面条件差不多的情况下，英语好除了可以使你获得更多机会外，薪水可以高出一千元。 10.使用final关键字修饰一个变量时，是引用不能变，还是引用的对象不能变？ 答：使用final关键字修饰一个变量时，是指引用变量不能变，引用变量所指向的对象中的内容还是可以改变的。 1234567891011121314解析： 例如，对于如下语句： final StringBuffer a=new StringBuffer(&quot;immutable&quot;); 执行如下语句将报告编译期错误： a=new StringBuffer(&quot;&quot;); 但是，执行如下语句则可以通过编译： a.append(&quot; broken!&quot;); 有人在定义方法的参数时，可能想采用如下形式来阻止方法内部修改传进来的参数对象： public void method(final StringBuffer param) &#123; &#125; 实际上，这是办不到的，在该方法内部仍然可以增加如下代码来修改参数对象： param.append(&quot;a&quot;); final在Java中是一个修饰词。修饰基础数据成员是final的主要用途，成员被修饰为常量，意味着成员只能被赋值一次便不可修改。 在Java中，我们无法让对象被修饰为final，而只能修饰对象的引用，这意味着即使你写public final A a = new A(); 事实上a指向的对象的数据依然可以被修改，不能修改的是a本身的引用值，即你不能再对a进行重赋值。同样的情况出现在数组中，比如public final int[] a = {1, 2, 3, 4, 5}，事实上a中的数值是可修改的，即可以写a[0] = 3。据目前了解，java中数组内的数据是无法修饰为不可修改的，而C/C++可以。 修饰方法的final和C/C++中修饰成员对象的const大不相同。首先，修饰方法的final含义不是“不可修改”，而是指该方法不可被继承成员重新定义。（注意，这里所说的不能被重新定义，并不是指子类一定不能定义同名方法，如果父类的方法是私有类型，子类是允许定义该方法的，这里指的不能重新定义是指不能通过改写方法来使得方法重写的多态性得以实现，如不希望A a = new B(); a.f();这样的重写方法情况出现）`public class A {// final方法fpublic final void f() {System.out.println(&quot;类A中的final方法f被调用了&quot;); }}public class B extends A { // 编译错误！父类的f方法是final类型，不可重写！ //! public void f() { //! System.out.println(“类B中的方法f被调用了”); //! }} ` **此外，当一个方法被修饰为final方法时，意味着编译器可能将该方法用内联(inline)方式载入，所谓内联方式，是指编译器不用像平常调用函数那样的方式来调用方法，而是直接将方法内的代码通过一定的修改后copy到原代码中。这样可以让代码执行的更快（因为省略了调用函数的开销），比如在int[] arr = new int[3]调用arr.length()等。 另一方面，私有方法也被编译器隐式修饰为final，这意味着private final void f()和private void f()并无区别。** 当一个类被修饰为final时，它的含义很明确，就是不允许该类被继承，也就是说，该类“绝后”了，任何继承它的操作都会以编译错误告终。这也凸显出Java用final而不用const作为标识符的理由。]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>Java面试宝典</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[int和integer的区别与用法]]></title>
    <url>%2F2018%2F02%2F12%2F2018%2F%E9%9A%8F%E6%89%8B%E8%AE%B0%2FJava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%9B%98%E7%82%B9%2F</url>
    <content type="text"><![CDATA[int 与 integer基本使用对比int int 是**基本类型**，直接存数值，进行初始化时int类的变量初始为0。 integer integer是对象，用一个引用指向这个对象，Integer的变量则初始化为null。 开发项目时Integer 与int 什么时候用？什么时候用Integer : 如果该属性所对应的数据库的字段是主键或者是外键时，用Integer；因为Integer的默认值为null，数据库的主键或者外键不能为空，但是可以为null 什么时候用int : 如果表示数量用int，因为int的默认值为0，它不能为null或者空 知识在于积累实践出真知 end]]></content>
      <categories>
        <category>随手记</category>
      </categories>
      <tags>
        <tag>Java随手记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[this和super的用法总结]]></title>
    <url>%2F2018%2F02%2F10%2F2018%2F%E9%9A%8F%E6%89%8B%E8%AE%B0%2FJava%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[这几天看到类在继承时会用到this和super，这里就做一点总结。 thisthis是自身的一个对象，代表对象本身，可以理解为：指向对象本身的一个指针。 this的三种用法： [普通的直接引用] [形参与成员名字重名，用this来区分：]1234567891011121314151617class Person &#123; private int age = 10; public Person()&#123; System.out.println(&quot;初始化年龄：&quot;+age);&#125; public int GetAge(int age)&#123; this.age = age; return this.age; &#125;&#125; public class test1 &#123; public static void main(String[] args) &#123; Person Harry = new Person(); System.out.println(&quot;Harry&apos;s age is &quot;+Harry.GetAge(12)); &#125;&#125; 运行结果： 初始化年龄：10 Harry’s age is 12 可以看到，这里age是GetAge成员方法的形参，this.age是Person类的成员变量。 [引用构造函数] supersuper可以理解为是指向自己超（父）类对象的一个指针，而这个超类指的是离自己最近的一个父类。 super的三种用法： [普通的直接引用] 与this类似，super相当于是指向当前对象的父类，这样就可以用super.xxx来引用父类的成员。 [子类中的成员变量或方法与父类中的成员变量或方法同名] 123456789101112131415161718192021class Country &#123; String name; void value() &#123; name = &quot;China&quot;; &#125;&#125; class City extends Country &#123; String name; void value() &#123; name = &quot;Shanghai&quot;; super.value(); //调用父类的方法 System.out.println(name); System.out.println(super.name); &#125; public static void main(String[] args) &#123; City c=new City(); c.value(); &#125;&#125; 运行结果： Shanghai China 可以看到，这里既调用了父类的方法，也调用了父类的变量。若不调用父类方法value()，只调用父类变量name的话，则父类name值为默认值null。 [引用构造函数] super（参数）：调用父类中的某一个构造函数（应该为构造函数中的第一条语句）。 this（参数）：调用本类中另一种形式的构造函数（应该为构造函数中的第一条语句）。 123456789101112131415161718192021222324252627282930313233343536class Person &#123; public static void prt(String s) &#123; System.out.println(s); &#125; Person() &#123; prt(&quot;父类·无参数构造方法： &quot;+&quot;A Person.&quot;); &#125;//构造方法(1) Person(String name) &#123; prt(&quot;父类·含一个参数的构造方法： &quot;+&quot;A person&apos;s name is &quot; + name); &#125;//构造方法(2) &#125; public class Chinese extends Person &#123; Chinese() &#123; super(); // 调用父类构造方法（1） prt(&quot;子类·调用父类”无参数构造方法“： &quot;+&quot;A chinese coder.&quot;); &#125; Chinese(String name) &#123; super(name);// 调用父类具有相同形参的构造方法（2） prt(&quot;子类·调用父类”含一个参数的构造方法“： &quot;+&quot;his name is &quot; + name); &#125; Chinese(String name, int age) &#123; this(name);// 调用具有相同形参的构造方法（3） prt(&quot;子类：调用子类具有相同形参的构造方法：his age is &quot; + age); &#125; public static void main(String[] args) &#123; Chinese cn = new Chinese(); cn = new Chinese(&quot;codersai&quot;); cn = new Chinese(&quot;codersai&quot;, 18); &#125; &#125; 运行结果： 父类·无参数构造方法： A Person. 子类·调用父类”无参数构造方法“： A chinese coder. 父类·含一个参数的构造方法： A person’s name is codersai 子类·调用父类”含一个参数的构造方法“： his name is codersai 父类·含一个参数的构造方法： A person’s name is codersai 子类·调用父类”含一个参数的构造方法“： his name is codersai 子类：调用子类具有相同形参的构造方法：his age is 18 从本例可以看到，可以用super和this分别调用父类的构造方法和本类中其他形式的构造方法。 例子中Chinese类第三种构造方法调用的是本类中第二种构造方法，而第二种构造方法是调用父类的，因此也要先调用父类的构造方法，再调用本类中第二种，最后是重写第三种构造方法。 super和this的异同： super（参数）：调用基类中的某一个构造函数（应该为构造函数中的第一条语句） this（参数）：调用本类中另一种形成的构造函数（应该为构造函数中的第一条语句） super: 它引用当前对象的直接父类中的成员（用来访问直接父类中被隐藏的父类中成员数据或函数，基类与派生类中有相同成员定义时如：super.变量名 super.成员函数据名（实参） this：它代表当前对象名（在程序中易产生二义性之处，应使用this来指明当前对象；如果函数的形参与类中的成员数据同名，这时需用this来指明成员变量名） 调用super()必须写在子类构造方法的第一行，否则编译不通过。每个子类构造方法的第一条语句，都是隐含地调用super()，如果父类没有这种形式的构造函数，那么在编译的时候就会报错。 super()和this()类似,区别是，super()从子类中调用父类的构造方法，this()在同一类内调用其它方法。 super()和this()均需放在构造方法内第一行。 尽管可以用this调用一个构造器，但却不能调用两个。 this和super不能同时出现在一个构造函数里面，因为this必然会调用其它的构造函数，其它的构造函数必然也会有super语句的存在，所以在同一个构造函数里面有相同的语句，就失去了语句的意义，编译器也不会通过。 this()和super()都指的是对象，所以，均不可以在static环境中使用。包括：static变量,static方法，static语句块。 从本质上讲，this是一个指向本对象的指针,然而super是一个Java关键字。 end 知识在于积累]]></content>
      <categories>
        <category>随手记</category>
      </categories>
      <tags>
        <tag>Java随手记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[需要了解的基础知识]]></title>
    <url>%2F2018%2F02%2F08%2F2018%2FJava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB%2FJava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E2%91%A0%2F</url>
    <content type="text"><![CDATA[Jre 和 Jdk 的区别?–JRE： （Java Runtime Environment），java 运行环境。包括Java虚拟机(JVM Java Virtual Machine)和 Java 程序所需的核心类库等，如果想要运行一个开发好的 Java 程序，计算机中只需要安装 JRE 即可。–JDK：（Java Development Kit Java） 开发工具包。JDK 是提供给 Java 开发人员使用的，其中包含了 java 的开发工具，也包括了 JRE。所以安装了 JDK，就不用在单独安装 JRE 了。其中的开发工具：编译工具(javac.exe) 打包工具(jar.exe) 等简单而言： 使用 JDK 开发完成的 Java 程序，交给 JRE 去运行。 1我的总结：必须熟练的记忆， 核心类库，开发工具！ Java 虚拟机 JVMJava Virtual Machine ，简称 JVM; 它是运行所有 Java 程序的抽象计算机,是 Java 语言的运行环境，它是 Java 最具吸引力的特性之一，JVM 读取并处理编译过的与平台无关的字节码(class)文件。Java 编译器针对 JVM 产生 class 文件，因此是独立于平台的。Java 解释器负责将 JVM 的代码在特定的平台上运行。Java 虚拟机是不跨平台的. Java 程序运行机制 .java文件—&gt;javac.exe编译—&gt;.class文件—&gt;java.exe运行—&gt;结果 编译: javac 文件名.文件后缀名运行: java 类名 1我的总结：Java 程序的组成：Java 源文件，字节码文件。 Java 成员变量和局部变量局部变量： 不是声明在类体括号里面的变量； 局部变量使用前必须初始化值; 局部变量没有默认初始化值; 局部变量的作用域是从定义开始到定义它的代码块结束; 成员变量: 在方法体外,类体内声明的变量，又称字段(Field)或全局变量；（其实 Java 中没有全 局变量，由于 Java是面向对象语言，所有变量都是类成员） 成员变量的作用域是整个类中; 1我的总结：注意成员变量和局部变量的区别 基本数据类型 在数据类型中，最常用也是最基础的数据类型，被称作基本数据类型。可以使用这些类型的值来代表一些简单的状态。 基本数据类型： 整数型： byte(字节型)，short(短整型)，int(整型)，long(长整型) 小数型： float(单精度浮点型)，double(双精度浮点型) 字符型： char(字符型) 布尔型：boolean(布尔型)]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[杂谈]]></title>
    <url>%2F2018%2F02%2F08%2F2018%2F02-08%2F%E6%9D%82%E8%B0%88%2F</url>
    <content type="text"><![CDATA[网易云音乐的那些事—“我们浪费掉了太多的青春，那是一段如此自以为是、又如此狼狈不堪的青春岁月，有欢笑，也有泪水；有朝气，也有颓废；有甜蜜，也有荒唐；有自信，也有迷茫。我们敏感，我们偏执，我们顽固到底地故作坚强；我们轻易的伤害别人，也轻易的被别人所伤，我们追逐于颓废的快乐，陶醉于寂寞的美丽…”——叶京 from -Auld Lang Syne—结婚的时候，她是伴娘。进入礼堂的时候和我站在一起，看着我将迎娶的新娘，她悄悄对我说了一句话让我红了眼眶。“我们终于一起步入结婚殿堂。” from -Beautiful In White (Demo)—当你喜欢一个优秀的人时，你会觉得自己千疮百孔。 from -遇见—最好的时代总在过去 from -初恋情人]]></content>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工具篇------FTPServer]]></title>
    <url>%2F2018%2F02%2F08%2F2018%2F%E4%BC%81%E4%B8%9A%E7%BA%A7%E9%A1%B9%E7%9B%AE%2F%E5%B7%A5%E5%85%B7%E7%AF%87-FTPServer%2F</url>
    <content type="text"><![CDATA[—轻量级FTP服务器简介轻量级FTP服务器软件,没有复杂的设置,没有复杂的操作,傻瓜都能搭建属于自己的FTP服务器! 下载 ftp server]]></content>
      <categories>
        <category>工具篇</category>
      </categories>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开启我的博客之旅]]></title>
    <url>%2F2018%2F02%2F07%2F2018%2F%E5%BC%80%E7%AF%87%2Fhello-blog%2F</url>
    <content type="text"><![CDATA[Welcome to Coder LiXinHua’s Blog!This is my first blog.Thank for you coming,and thank for your support.They are the energy to encourage me to move forward.From now on, I will update my blog regularly.I will record my learning knowledge here. Truth优秀的人，不是不合群，而是他们合群的人里面没有你]]></content>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
</search>
