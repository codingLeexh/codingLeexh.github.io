<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[int和integer的区别与用法]]></title>
    <url>%2F2018%2F02%2F12%2F2018%2F%E9%9A%8F%E6%89%8B%E8%AE%B0%2FJava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%9B%98%E7%82%B9%2F</url>
    <content type="text"><![CDATA[int 与 integer基本使用对比int int 是**基本类型**，直接存数值，进行初始化时int类的变量初始为0。 integer integer是对象，用一个引用指向这个对象，Integer的变量则初始化为null。 开发项目时Integer 与int 什么时候用？什么时候用Integer : 如果该属性所对应的数据库的字段是主键或者是外键时，用Integer；因为Integer的默认值为null，数据库的主键或者外键不能为空，但是可以为null 什么时候用int : 如果表示数量用int，因为int的默认值为0，它不能为null或者空 知识在于积累实践出真知 end]]></content>
      <categories>
        <category>随手记</category>
      </categories>
      <tags>
        <tag>Java随手记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[this和super的用法总结]]></title>
    <url>%2F2018%2F02%2F10%2F2018%2F%E9%9A%8F%E6%89%8B%E8%AE%B0%2FJava%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[这几天看到类在继承时会用到this和super，这里就做一点总结。 thisthis是自身的一个对象，代表对象本身，可以理解为：指向对象本身的一个指针。 this的三种用法： [普通的直接引用] [形参与成员名字重名，用this来区分：]1234567891011121314151617class Person &#123; private int age = 10; public Person()&#123; System.out.println(&quot;初始化年龄：&quot;+age);&#125; public int GetAge(int age)&#123; this.age = age; return this.age; &#125;&#125; public class test1 &#123; public static void main(String[] args) &#123; Person Harry = new Person(); System.out.println(&quot;Harry&apos;s age is &quot;+Harry.GetAge(12)); &#125;&#125; 运行结果： 初始化年龄：10 Harry’s age is 12 可以看到，这里age是GetAge成员方法的形参，this.age是Person类的成员变量。 [引用构造函数] supersuper可以理解为是指向自己超（父）类对象的一个指针，而这个超类指的是离自己最近的一个父类。 super的三种用法： [普通的直接引用] 与this类似，super相当于是指向当前对象的父类，这样就可以用super.xxx来引用父类的成员。 [子类中的成员变量或方法与父类中的成员变量或方法同名] 123456789101112131415161718192021class Country &#123; String name; void value() &#123; name = &quot;China&quot;; &#125;&#125; class City extends Country &#123; String name; void value() &#123; name = &quot;Shanghai&quot;; super.value(); //调用父类的方法 System.out.println(name); System.out.println(super.name); &#125; public static void main(String[] args) &#123; City c=new City(); c.value(); &#125;&#125; 运行结果： Shanghai China 可以看到，这里既调用了父类的方法，也调用了父类的变量。若不调用父类方法value()，只调用父类变量name的话，则父类name值为默认值null。 [引用构造函数] super（参数）：调用父类中的某一个构造函数（应该为构造函数中的第一条语句）。 this（参数）：调用本类中另一种形式的构造函数（应该为构造函数中的第一条语句）。 123456789101112131415161718192021222324252627282930313233343536class Person &#123; public static void prt(String s) &#123; System.out.println(s); &#125; Person() &#123; prt(&quot;父类·无参数构造方法： &quot;+&quot;A Person.&quot;); &#125;//构造方法(1) Person(String name) &#123; prt(&quot;父类·含一个参数的构造方法： &quot;+&quot;A person&apos;s name is &quot; + name); &#125;//构造方法(2) &#125; public class Chinese extends Person &#123; Chinese() &#123; super(); // 调用父类构造方法（1） prt(&quot;子类·调用父类”无参数构造方法“： &quot;+&quot;A chinese coder.&quot;); &#125; Chinese(String name) &#123; super(name);// 调用父类具有相同形参的构造方法（2） prt(&quot;子类·调用父类”含一个参数的构造方法“： &quot;+&quot;his name is &quot; + name); &#125; Chinese(String name, int age) &#123; this(name);// 调用具有相同形参的构造方法（3） prt(&quot;子类：调用子类具有相同形参的构造方法：his age is &quot; + age); &#125; public static void main(String[] args) &#123; Chinese cn = new Chinese(); cn = new Chinese(&quot;codersai&quot;); cn = new Chinese(&quot;codersai&quot;, 18); &#125; &#125; 运行结果： 父类·无参数构造方法： A Person. 子类·调用父类”无参数构造方法“： A chinese coder. 父类·含一个参数的构造方法： A person’s name is codersai 子类·调用父类”含一个参数的构造方法“： his name is codersai 父类·含一个参数的构造方法： A person’s name is codersai 子类·调用父类”含一个参数的构造方法“： his name is codersai 子类：调用子类具有相同形参的构造方法：his age is 18 从本例可以看到，可以用super和this分别调用父类的构造方法和本类中其他形式的构造方法。 例子中Chinese类第三种构造方法调用的是本类中第二种构造方法，而第二种构造方法是调用父类的，因此也要先调用父类的构造方法，再调用本类中第二种，最后是重写第三种构造方法。 super和this的异同： super（参数）：调用基类中的某一个构造函数（应该为构造函数中的第一条语句） this（参数）：调用本类中另一种形成的构造函数（应该为构造函数中的第一条语句） super: 它引用当前对象的直接父类中的成员（用来访问直接父类中被隐藏的父类中成员数据或函数，基类与派生类中有相同成员定义时如：super.变量名 super.成员函数据名（实参） this：它代表当前对象名（在程序中易产生二义性之处，应使用this来指明当前对象；如果函数的形参与类中的成员数据同名，这时需用this来指明成员变量名） 调用super()必须写在子类构造方法的第一行，否则编译不通过。每个子类构造方法的第一条语句，都是隐含地调用super()，如果父类没有这种形式的构造函数，那么在编译的时候就会报错。 super()和this()类似,区别是，super()从子类中调用父类的构造方法，this()在同一类内调用其它方法。 super()和this()均需放在构造方法内第一行。 尽管可以用this调用一个构造器，但却不能调用两个。 this和super不能同时出现在一个构造函数里面，因为this必然会调用其它的构造函数，其它的构造函数必然也会有super语句的存在，所以在同一个构造函数里面有相同的语句，就失去了语句的意义，编译器也不会通过。 this()和super()都指的是对象，所以，均不可以在static环境中使用。包括：static变量,static方法，static语句块。 从本质上讲，this是一个指向本对象的指针,然而super是一个Java关键字。 end 知识在于积累]]></content>
      <categories>
        <category>随手记</category>
      </categories>
      <tags>
        <tag>Java随手记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[需要了解的基础知识]]></title>
    <url>%2F2018%2F02%2F08%2F2018%2FJava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB%2FJava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E2%91%A0%2F</url>
    <content type="text"><![CDATA[Jre 和 Jdk 的区别?–JRE： （Java Runtime Environment），java 运行环境。包括Java虚拟机(JVM Java Virtual Machine)和 Java 程序所需的核心类库等，如果想要运行一个开发好的 Java 程序，计算机中只需要安装 JRE 即可。–JDK：（Java Development Kit Java） 开发工具包。JDK 是提供给 Java 开发人员使用的，其中包含了 java 的开发工具，也包括了 JRE。所以安装了 JDK，就不用在单独安装 JRE 了。其中的开发工具：编译工具(javac.exe) 打包工具(jar.exe) 等简单而言： 使用 JDK 开发完成的 Java 程序，交给 JRE 去运行。 1我的总结：必须熟练的记忆， 核心类库，开发工具！ Java 虚拟机 JVMJava Virtual Machine ，简称 JVM; 它是运行所有 Java 程序的抽象计算机,是 Java 语言的运行环境，它是 Java 最具吸引力的特性之一，JVM 读取并处理编译过的与平台无关的字节码(class)文件。Java 编译器针对 JVM 产生 class 文件，因此是独立于平台的。Java 解释器负责将 JVM 的代码在特定的平台上运行。Java 虚拟机是不跨平台的. Java 程序运行机制 .java文件—&gt;javac.exe编译—&gt;.class文件—&gt;java.exe运行—&gt;结果 编译: javac 文件名.文件后缀名运行: java 类名 1我的总结：Java 程序的组成：Java 源文件，字节码文件。 Java 成员变量和局部变量局部变量： 不是声明在类体括号里面的变量； 局部变量使用前必须初始化值; 局部变量没有默认初始化值; 局部变量的作用域是从定义开始到定义它的代码块结束; 成员变量: 在方法体外,类体内声明的变量，又称字段(Field)或全局变量；（其实 Java 中没有全 局变量，由于 Java是面向对象语言，所有变量都是类成员） 成员变量的作用域是整个类中; 1我的总结：注意成员变量和局部变量的区别 基本数据类型 在数据类型中，最常用也是最基础的数据类型，被称作基本数据类型。可以使用这些类型的值来代表一些简单的状态。 基本数据类型： 整数型： byte(字节型)，short(短整型)，int(整型)，long(长整型) 小数型： float(单精度浮点型)，double(双精度浮点型) 字符型： char(字符型) 布尔型：boolean(布尔型)]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[杂谈]]></title>
    <url>%2F2018%2F02%2F08%2F2018%2F02-08%2F%E6%9D%82%E8%B0%88%2F</url>
    <content type="text"><![CDATA[网易云音乐的那些事—“我们浪费掉了太多的青春，那是一段如此自以为是、又如此狼狈不堪的青春岁月，有欢笑，也有泪水；有朝气，也有颓废；有甜蜜，也有荒唐；有自信，也有迷茫。我们敏感，我们偏执，我们顽固到底地故作坚强；我们轻易的伤害别人，也轻易的被别人所伤，我们追逐于颓废的快乐，陶醉于寂寞的美丽…”——叶京 from -Auld Lang Syne—结婚的时候，她是伴娘。进入礼堂的时候和我站在一起，看着我将迎娶的新娘，她悄悄对我说了一句话让我红了眼眶。“我们终于一起步入结婚殿堂。” from -Beautiful In White (Demo)—当你喜欢一个优秀的人时，你会觉得自己千疮百孔。 from -遇见—最好的时代总在过去 from -初恋情人]]></content>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工具篇------FTPServer]]></title>
    <url>%2F2018%2F02%2F08%2F2018%2F%E4%BC%81%E4%B8%9A%E7%BA%A7%E9%A1%B9%E7%9B%AE%2F%E5%B7%A5%E5%85%B7%E7%AF%87-FTPServer%2F</url>
    <content type="text"><![CDATA[—轻量级FTP服务器简介轻量级FTP服务器软件,没有复杂的设置,没有复杂的操作,傻瓜都能搭建属于自己的FTP服务器! 下载 ftp server]]></content>
      <categories>
        <category>工具篇</category>
      </categories>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开启我的博客之旅]]></title>
    <url>%2F2018%2F02%2F07%2F2018%2F%E5%BC%80%E7%AF%87%2Fhello-blog%2F</url>
    <content type="text"><![CDATA[Welcome to Coder LiXinHua’s Blog!This is my first blog.Thank for you coming,and thank for your support.They are the energy to encourage me to move forward.From now on, I will update my blog regularly.I will record my learning knowledge here. Truth优秀的人，不是不合群，而是他们合群的人里面没有你]]></content>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
</search>
