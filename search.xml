<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[写给我的一个朋友]]></title>
    <url>%2F2018%2F02%2F27%2F2018%2F%E5%86%99%E7%BB%99%E6%88%91%E7%9A%84%E4%B8%80%E4%B8%AA%E6%9C%8B%E5%8F%8B%2F%E5%86%99%E7%BB%99%E6%88%91%E7%9A%84%E4%B8%80%E4%B8%AA%E6%9C%8B%E5%8F%8B%2F</url>
    <content type="text"><![CDATA[大学两年多，自己没有好好努力所以没学到什么东西。书到用时方恨少，看到老友们纷纷转行，心中深觉可惜。于此，新的一年从零开始，觉醒自己的兽性，经过一个多月的努力，总结了以下学识，仅供给老友参考。也希望老友能尽快找回自己的路。当你看到这篇文章的时候，我可能已经在深圳忙碌的找工作了。 这篇文章可能没有什么技术性的东西，这只是总结适用我个人Java学习的一个路线，但如果你跟我之前一样找不到学习方向的话，建议你不妨看看，亦可查缺补漏 Java前篇 Java的基础知识，由于网上很多相关教程，总结的都很不错，我在此也不做解释了，并且我也坚信老友的基础还是比我强的多。给出教程地址仅供参考： JAVA基础-菜鸟教程 在此，我主要讲诉JavaWeb开发学习路线(此次总结是根据我个人学习所得，很多重要知识不全只能慢慢追赶) JavaWeb学习路线(codinglixh’s conclusion)需要掌握的： 前端技术(不解释) 简单理解http请求 JSP servlet jdbc Spring SpringMVC Mybatis 框架整合 项目实践 项目优化 Redis Tomcat集群 HTTP理解http协议 JSP JSP的详解 Servlet Servlet详解 JSP和Servlet区别 想起我们Java老师经典的话，jsp就是在html里面写java代码，servlet就是在java里面写html代码。其实jsp经过容器解释之后就是servlet。只是我们自己写代码的时候尽量能让它们各司其职，jsp更注重前端显示，servlet更注重模型和业务逻辑。 主要理解以下三点： 1.不同之处在哪？ [x] Servlet在Java代码中通过HttpServletResponse对象动态输出HTML内容 [x] JSP在静态HTML内容中嵌入Java代码，Java代码被动态执行后生成HTML内容 2.各自的特点 [x] Servlet能够很好地组织业务逻辑代码，但是在Java源文件中通过字符串拼接的方式生成动态HTML内容会导致代码维护困难、可读性差 [x] JSP虽然规避了Servlet在生成HTML内容方面的劣势，但是在HTML中混入大量、复杂的业务逻辑同样也是不可取的 通过MVC双剑合璧 既然JSP和Servlet都有自身的适用环境，那么能否扬长避短，让它们发挥各自的优势呢？答案是肯定的——MVC(Model-View-Controller)模式非常适合解决这一问题。(MVC模式利用springMVC时详细介绍) MVC模式（Model-View-Controller）是软件工程中的一种软件架构模式，把软件系统分为三个基本部分：模型（Model）、视图（View）和控制器（Controller）： [x] Model——业务功能编写（例如算法实现）、数据库设计以及数据存取操作实现 [x] View——负责界面显示 [x] Controller——负责转发请求，对请求进行处理 在JSP/Servlet开发的软件系统中，这三个部分的描述如下所示： Web浏览器发送HTTP请求到服务端，被Controller(Servlet)获取并进行处理（例如参数解析、请求转发） Controller(Servlet)调用核心业务逻辑——Model部分，获得结果 Controller(Servlet)将逻辑处理结果交给View（JSP），动态输出HTML内容 Controller(Servlet)将逻辑处理结果交给View（JSP），动态输出HTML内容 MVC模式在Web开发中的好处是非常明显，它规避了JSP与Servlet各自的短板，Servlet只负责业务逻辑而不会通过out.append()动态生成HTML代码；JSP中也不会充斥着大量的业务代码。这大大提高了代码的可读性和可维护性。 所以，在后续的项目开发中，jsp专注于页面设计，servlet专注于业务逻辑。值得注意的是JSP实质还是Servlet。 在你没有弄懂servlet底层机制之前，还是不要去学习框架为好 JDBC JDBC详解 如果你忘了jdbc是什么，可以回去看看以前的web项目中，老师带我们写的DataUtil.java就明白了。 这里简单介绍： JDBC 指 Java 数据库连接，是一种标准Java应用编程接口（ JAVA API），用来连接 Java 编程语言和广泛的数据库。 以下是结构图，其中显示了驱动程序管理器相对于在 JDBC 驱动程序和 Java 应用程序所处的位置。 常见的JDBC组件 DriverManager：这个类管理一系列数据库驱动程序。匹配连接使用通信子协议从 JAVA 应用程序中请求合适的数据库驱动程序。识别 JDBC 下某个子协议的第一驱动程序将被用于建立数据库连接。 Driver: 这个接口处理与数据库服务器的通信。你将很少直接与驱动程序互动。相反，你使用 DriverManager 中的对象，它管理此类型的对象。它也抽象与驱动程序对象工作相关的详细信息。 Connection: 此接口具有接触数据库的所有方法。该连接对象表示通信上下文，即，所有与数据库的通信仅通过这个连接对象进行。 Statement: 使用创建于这个接口的对象将 SQL 语句提交到数据库。除了执行存储过程以外，一些派生的接口也接受参数。 ResultSet : 在你使用语句对象执行 SQL 查询后，这些对象保存从数据获得的数据。它作为一个迭代器，让您可以通过它的数据来移动。 SQLException : 这个类处理发生在数据库应用程序的任何错误。 基础的jdbc编程代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219Class.forName(driverClass)//加载MySql驱动Class.forName(&quot;com.mysql.jdbc.Driver&quot;)//加载Oracle驱动Class.forName(&quot;oracle.jdbc.driver.OracleDriver&quot;)//获得数据库连接：DriverManager.getConnection(&quot;jdbc:mysql://127.0.0.1:3306/数据库名称&quot;, &quot;root&quot;, &quot;root&quot;);//创建Statement\PreparedStatement对象：conn.createStatement();conn.prepareStatement(sql);连接数据库实例：import java.sql.Connection;import java.sql.DriverManager;import java.sql.ResultSet;import java.sql.Statement;public class DbUtil &#123; public static final String URL = &quot;jdbc:mysql://localhost:3306/数据库名称&quot;; public static final String USER = &quot;root&quot;; public static final String PASSWORD = &quot;root&quot;; public static void main(String[] args) throws Exception &#123; //1.加载驱动程序 Class.forName(&quot;com.mysql.jdbc.Driver&quot;); //2. 获得数据库连接 Connection conn = DriverManager.getConnection(URL, USER, PASSWORD); //3.操作数据库，实现增删改查 Statement stmt = conn.createStatement(); ResultSet rs = stmt.executeQuery(&quot;SELECT user_name, age FROM tb_goddess&quot;); //如果有数据，rs.next()返回true while(rs.next())&#123; System.out.println(rs.getString(&quot;user_name&quot;)+&quot; 年龄：&quot;+rs.getInt(&quot;age&quot;)); &#125; &#125;&#125;实现增删改查：package cn.codinglixh.db;import java.sql.Connection;import java.sql.DriverManager;import java.sql.ResultSet;import java.sql.Statement;public class DbUtil &#123; public static final String URL = &quot;jdbc:mysql://localhost:3306/数据库名称&quot;; public static final String USER = &quot;root&quot;; public static final String PASSWORD = &quot;root&quot;; private static Connection conn = null; static&#123; try &#123; //1.加载驱动程序 Class.forName(&quot;com.mysql.jdbc.Driver&quot;); //2. 获得数据库连接 conn = DriverManager.getConnection(URL, USER, PASSWORD); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; public static Connection getConnection()&#123; return conn; &#125;&#125;//模型package cn.codinglixh.entity;import java.util.Date;public class Goddess &#123; private Integer id; private String user_name; private Integer sex; private Integer age; private Date birthday; //注意用的是java.util.Date private String email; private String mobile; private String create_user; private String update_user; private Date create_date; private Date update_date; private Integer isDel; //getter setter方法。。。&#125;//---------dao层--------------package cn.codinglixh.dao;import cn.codinglixh.db.DbUtil;import cn.codinglixh.entity.Goddess;import java.sql.Connection;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;import java.util.ArrayList;import java.util.List;public class GoddessDao &#123; //增加 public void addGoddess(Goddess g) throws SQLException &#123; //获取连接 Connection conn = DbUtil.getConnection(); //sql String sql = &quot;INSERT INTO tb_goddess(user_name, sex, age, birthday, email, mobile,&quot;+ &quot;create_user, create_date, update_user, update_date, isdel)&quot; +&quot;values(&quot;+&quot;?,?,?,?,?,?,?,CURRENT_DATE(),?,CURRENT_DATE(),?)&quot;; //预编译 PreparedStatement ptmt = conn.prepareStatement(sql); //预编译SQL，减少sql执行 //传参 ptmt.setString(1, g.getUser_name()); ptmt.setInt(2, g.getSex()); ptmt.setInt(3, g.getAge()); ptmt.setDate(4, new Date(g.getBirthday().getTime())); ptmt.setString(5, g.getEmail()); ptmt.setString(6, g.getMobile()); ptmt.setString(7, g.getCreate_user()); ptmt.setString(8, g.getUpdate_user()); ptmt.setInt(9, g.getIsDel()); //执行 ptmt.execute(); &#125; public void updateGoddess()&#123; //获取连接 Connection conn = DbUtil.getConnection(); //sql, 每行加空格 String sql = &quot;UPDATE tb_goddess&quot; + &quot; set user_name=?, sex=?, age=?, birthday=?, email=?, mobile=?,&quot;+ &quot; update_user=?, update_date=CURRENT_DATE(), isdel=? &quot;+ &quot; where id=?&quot;; //预编译 PreparedStatement ptmt = conn.prepareStatement(sql); //预编译SQL，减少sql执行 //传参 ptmt.setString(1, g.getUser_name()); ptmt.setInt(2, g.getSex()); ptmt.setInt(3, g.getAge()); ptmt.setDate(4, new Date(g.getBirthday().getTime())); ptmt.setString(5, g.getEmail()); ptmt.setString(6, g.getMobile()); ptmt.setString(7, g.getUpdate_user()); ptmt.setInt(8, g.getIsDel()); ptmt.setInt(9, g.getId()); //执行 ptmt.execute(); &#125; public void delGoddess()&#123; //获取连接 Connection conn = DbUtil.getConnection(); //sql, 每行加空格 String sql = &quot;delete from tb_goddess where id=?&quot;; //预编译SQL，减少sql执行 PreparedStatement ptmt = conn.prepareStatement(sql); //传参 ptmt.setInt(1, id); //执行 ptmt.execute(); &#125; public List&lt;Goddess&gt; query() throws SQLException &#123; Connection conn = DbUtil.getConnection(); Statement stmt = conn.createStatement(); ResultSet rs = stmt.executeQuery(&quot;SELECT user_name, age FROM tb_goddess&quot;); List&lt;Goddess&gt; gs = new ArrayList&lt;Goddess&gt;(); Goddess g = null; while(rs.next())&#123; g = new Goddess(); g.setUser_name(rs.getString(&quot;user_name&quot;)); g.setAge(rs.getInt(&quot;age&quot;)); gs.add(g); &#125; return gs; &#125; public Goddess get()&#123; Goddess g = null; //获取连接 Connection conn = DbUtil.getConnection(); //sql, 每行加空格 String sql = &quot;select * from tb_goddess where id=?&quot;; //预编译SQL，减少sql执行 PreparedStatement ptmt = conn.prepareStatement(sql); //传参 ptmt.setInt(1, id); //执行 ResultSet rs = ptmt.executeQuery(); while(rs.next())&#123; g = new Goddess(); g.setId(rs.getInt(&quot;id&quot;)); g.setUser_name(rs.getString(&quot;user_name&quot;)); g.setAge(rs.getInt(&quot;age&quot;)); g.setSex(rs.getInt(&quot;sex&quot;)); g.setBirthday(rs.getDate(&quot;birthday&quot;)); g.setEmail(rs.getString(&quot;email&quot;)); g.setMobile(rs.getString(&quot;mobile&quot;)); g.setCreate_date(rs.getDate(&quot;create_date&quot;)); g.setCreate_user(rs.getString(&quot;create_user&quot;)); g.setUpdate_date(rs.getDate(&quot;update_date&quot;)); g.setUpdate_user(rs.getString(&quot;update_user&quot;)); g.setIsDel(rs.getInt(&quot;isdel&quot;)); &#125; return g; &#125;&#125; 到此，一个Web项目所需要的基础技术你已经掌握了。这时候你需要写一个项目来深入理解。 可以参考我写的一个客户管理系统 源码。你也可以自行百度一个更好的项目锻炼自己。 你可以参考上面jdbc代码做一个项目，这里用另一个简单的项目介绍： 项目环境： 1234567jdk1.8Tomcat8.5IDEA2017MySql 项目功能： 用户登录(使用JSP+Servlet+jdbc,只做了登陆验证所有没有用JavaBean) 创建数据库，创建表 sql代码： 123456789101112131415161718192021222324252627282930313233343536/* Navicat Premium Data Transfer Source Server : 192.168.1.104 Source Server Type : MySQL Source Server Version : 50720 Source Host : localhost:3306 Source Schema : jdbc Target Server Type : MySQL Target Server Version : 50720 File Encoding : 65001 Date: 27/02/2018 17:35:44*/SET NAMES utf8mb4;SET FOREIGN_KEY_CHECKS = 0;-- ------------------------------ Table structure for tb_user-- ----------------------------DROP TABLE IF EXISTS `tb_user`;CREATE TABLE `tb_user` ( `id` int(11) NOT NULL COMMENT &apos;用户id&apos;, `username` varchar(12) CHARACTER SET utf8 COLLATE utf8_bin NOT NULL COMMENT &apos;登录名&apos;, `password` varchar(16) CHARACTER SET utf8 COLLATE utf8_bin NOT NULL COMMENT &apos;密码&apos;, PRIMARY KEY (`id`) USING BTREE) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_bin ROW_FORMAT = Dynamic;-- ------------------------------ Records of tb_user-- ----------------------------INSERT INTO `tb_user` VALUES (1, &apos;admin&apos;, &apos;admin&apos;);SET FOREIGN_KEY_CHECKS = 1; IDEA中新建Web工程(暂时不介绍maven) 大致结构 创建DataUtil.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package cn.codinglixh.util;import java.sql.*;/** * @author Lixinhua * @email codingLixh@163.com * @date 2018/2/27 17:55 */public class DataUtil &#123; public static final String URL = &quot;jdbc:mysql://localhost:3306/jdbc&quot;; public static final String USER = &quot;root&quot;; public static final String PASSWORD = &quot;1234&quot;; private static Connection conn = null; public static Statement st = null;//定义statement public ResultSet result = null;//定义结果集 static&#123; try &#123; //1.加载驱动程序 Class.forName(&quot;com.mysql.jdbc.Driver&quot;); //2. 获得数据库连接 conn = DriverManager.getConnection(URL, USER, PASSWORD); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; public static Connection getConnection()&#123; return conn; &#125; //关闭数据库连接 public void close()&#123; try&#123; if (result != null)result.close(); if (st != null)st.close(); if (conn != null)conn.close(); &#125;catch(Exception ex)&#123; ex.printStackTrace(); &#125; &#125;&#125; 创建UserDao.java 123456789101112131415161718192021222324package cn.codinglixh.dao;import cn.codinglixh.util.DataUtil;import java.sql.Connection;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;/** * @author Lixinhua * @email codingLixh@163.com * @date 2018/2/27 17:59 */public class UserDao &#123; //验证登陆的用户数据 public ResultSet query(String sql) throws SQLException &#123; Connection conn= DataUtil.getConnection(); Statement stmt = conn.createStatement(); ResultSet rs =stmt.executeQuery(sql); return rs; &#125;&#125; 创建UserServlet 12345678910111213141516171819202122232425262728293031323334353637383940414243package cn.codinglixh.service;import cn.codinglixh.dao.UserDao;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.sql.ResultSet;import java.sql.SQLException;/** * @author Lixinhua * @email codingLixh@163.com * @date 2018/2/27 18:28 */public class UserServlet extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //验证登录 UserDao userDao=new UserDao(); //获取从前端输入的用户名和密码 String username= new String(request.getParameter(&quot;username&quot;).getBytes(&quot;iso-8859-1&quot;),&quot;utf-8&quot;); String password= new String(request.getParameter(&quot;password&quot;).getBytes(&quot;iso-8859-1&quot;),&quot;utf-8&quot;); try &#123; String sql = &quot;select * from tb_user where username=&apos;&quot;+username+&quot;&apos; and password=&apos;&quot;+password+&quot;&apos;&quot;;//创建sql ResultSet rs = userDao.query(sql); if(rs.next())&#123; response.sendRedirect(&quot;/success.jsp&quot;); &#125; else&#123; response.sendRedirect(&quot;/error.jsp&quot;); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; &#125;&#125; 配置web.xml 123456789101112131415161718&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot; version=&quot;3.1&quot;&gt; &lt;servlet&gt; &lt;servlet-name&gt;LoginServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;cn.codinglixh.service.UserServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;LoginServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/LoginServlet&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt;&lt;/web-app&gt; 创建前端页面： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181.index.jsp:&lt;%-- Created by IntelliJ IDEA. User: self-consciousness Date: 2018/2/27 Time: 17:39 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;用户登录&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; table &#123; margin-top: 360px; &#125; body &#123; color: #000; font-size: 12px; margin: 0px auto; &#125; &lt;/style&gt; &lt;script type=&quot;text/javascript&quot;&gt; function check(form) &#123; //document.forms.form1.username.value取得form1中Username的值 并判断是否为空 if (document.forms.form1.username.value == &quot;&quot;) &#123; //如果 为&quot;&quot;则弹出提示 alert(&quot;pls input username&quot;); //将输入焦点定位到没有输入的地方 document.forms.form1.username.focus(); //返回错误 return false; &#125; if (document.forms.form1.password.value == &quot;&quot;) &#123; alert(&quot;pls input password&quot;); document.forms.form1.password.focus(); return false; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;LoginServlet&quot; method=&quot;post&quot; name=&quot;form1&quot;&gt; &lt;table border=&quot;1&quot; cellspacing=&quot;1&quot; cellpadding=&quot;1&quot; bordercolor=&quot;silver&quot; align=&quot;center&quot;&gt; &lt;tr&gt; &lt;td colspan=&quot;2&quot; align=&quot;center&quot; bgcolor=&quot;#e8e8e8&quot;&gt;用户登陆&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;用户名：&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;username&quot;/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;密码：&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;password&quot; name=&quot;password&quot;/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;!-- onclick=&quot;return check(this) 调用上面的Script进行验证 --&gt; &lt;td&gt;&lt;input type=&quot;submit&quot; name=&quot;submit&quot; onclick=&quot;return check(this);&quot;/&gt;&lt;input type=&quot;reset&quot; name=&quot;重置&quot;/&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;2.success.jsp:&lt;%@ page import=&quot;java.util.Date&quot; %&gt;&lt;%-- Created by IntelliJ IDEA. User: self-consciousness Date: 2018/2/27 Time: 18:26 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 登陆成功！ &lt;% Date today = new Date(); int d = today.getDay(); int h = today.getHours(); String s = &quot;&quot;; if(h&gt;0 &amp;&amp; h &lt; 12) s = &quot;上午好&quot;; else if(h&gt;=12) s = &quot;下午好&quot;; String day[] = &#123;&quot;日&quot;,&quot;一&quot;,&quot;二&quot;,&quot;三&quot;,&quot;四&quot;,&quot;五&quot;,&quot;六&quot;&#125;; out.println(s+ &quot;，今天是星期&quot; + day[d]); %&gt;&lt;/body&gt;&lt;/html&gt;3.error.jsp&lt;%-- Created by IntelliJ IDEA. User: self-consciousness Date: 2018/2/27 Time: 18:24 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;错误！&lt;/title&gt;&lt;/head&gt;&lt;body&gt;error&lt;a href=&quot;index.jsp&quot;&gt;点击这里返回&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 到此一个超级简单的登陆功能就结束了，另外记得导入mysql驱动包。Servlet原理解析 附上图析： 深入的理解应该做更多的操作，所有老友赶紧coding Spring 当你做了几个普通的Servlet项目后，你会发现项目的业务逻辑相当复杂，代码重用，高度耦合。这时候就用框架来简化开发。 Spring入门介绍 看完介绍后基于一个简单的项目来了解Spring： 创建一个项目 导入jar(由于项目由maven管理所以先提供pom.xml配置，如果你是普通web项目，也可以通过名字下载对应jar) 123456789101112131415161718192021222324252627282930&lt;!-- Spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;4.3.12.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;4.3.12.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.3.12.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;4.3.12.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt; &lt;version&gt;RELEASE&lt;/version&gt; &lt;/dependency&gt; 创建一个dao，service层接口： 123456789101112131415161718192021222324package cn.codinglixh.spring.dao;/** * @author Lixinhua * @email codingLixh@163.com * @date 2018/2/27 14:44 */public interface IPersonDao &#123; //假如做一个添加用户的功能 public void addPerson();&#125;-----------------------------------------package cn.codinglixh.spring.service;/** * @author Lixinhua * @email codingLixh@163.com * @date 2018/2/27 14:55 */public interface IPersonService &#123; public void addPerson();&#125; 接口实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243package cn.codinglixh.spring.dao.impl;import cn.codinglixh.spring.dao.IPersonDao;/** * @author Lixinhua * @email codingLixh@163.com * @date 2018/2/27 14:54 */public class PersonDaoImpl implements IPersonDao&#123; @Override public void addPerson() &#123; System.out.println(&quot;addPerson()&quot;); &#125;&#125;-----------------------------------------package cn.codinglixh.spring.service.impl;import cn.codinglixh.spring.dao.IPersonDao;import cn.codinglixh.spring.service.IPersonService;/** * @author Lixinhua * @email codingLixh@163.com * @date 2018/2/27 14:56 */public class PersonService implements IPersonService&#123; private IPersonDao personDao; public void setPersonDao(IPersonDao personDao) &#123; this.personDao = personDao; &#125; @Override public void addPerson() &#123; System.out.printf(&quot;........from service addPerson()&quot;); personDao.addPerson(); &#125;&#125; 创建spring的核心配置文件 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;personDao&quot; class=&quot;cn.codinglixh.spring.dao.impl.PersonDaoImpl&quot;/&gt; &lt;bean id=&quot;personService&quot; class=&quot;cn.codinglixh.spring.service.impl.PersonService&quot;&gt; &lt;property name=&quot;personDao&quot; ref=&quot;personDao&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 创建测试类： 12345678910111213141516171819202122232425262728package cn.codinglixh.spring.test;import cn.codinglixh.spring.service.IPersonService;import org.junit.Before;import org.junit.Test;import org.springframework.beans.factory.BeanFactory;import org.springframework.context.support.ClassPathXmlApplicationContext;/** * @author Lixinhua * @email codingLixh@163.com * @date 2018/2/27 14:58 */public class PersonServiceTest &#123; private BeanFactory beanFactory =null; @Before public void before()&#123; beanFactory =new ClassPathXmlApplicationContext(&quot;spring-context.xml&quot;); &#125; @Test public void test()&#123; IPersonService personService=(IPersonService) beanFactory.getBean(&quot;personService&quot;); personService.addPerson(); &#125;&#125; 运行测试类： 12345结果：........from service addPerson()addPerson() Spring的作用得慢慢参悟。重点理解IOC/AOP。 springMVC及Mybatis 谈不上熟悉，只能简单的了解怎么使用。所有只好以项目代入。 项目篇]]></content>
      <categories>
        <category>时光</category>
      </categories>
      <tags>
        <tag>Myfriend</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring入门]]></title>
    <url>%2F2018%2F02%2F27%2F2018%2FSpring%2FSpring%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[做过一些基于Spring的项目，却一直不理解什么是Spring,趁现在还有一点空闲，赶紧google彻底认识一波 1因为要学习，就需要记录、沉淀、积累，所以就以写笔记的方式来见证学习的成长。 什么是spring？ 简要的说：Spring是一个开发应用框架(- -| ) 什么样的框架呢？有这么几个标签： 1轻量级、 非侵入式、 一站式、 模块化 使用Spring的目的？ 其目的是用于简化企业级应用程序开发 一个完整的应用是由一组相互协作的++对象++组成。所以开发一个应用除了要开发业务逻辑之外，最多的是关注如何使这些对象协作来完成所需功能，而且要低耦合、高内聚。 业务逻辑开发是不可避免的，那如果有个框架出来帮我们来创建对象及管理这些对象之间的依赖关系。当然，我们也可以通过自我能力，利用前人总结出来的设计模式来进行我们的架构设计，比如常见的「工厂模式」、「代理模式」等，总共有23种模式，利用别人总结的轮子来进行我们自己轮子建造，但如果这些轮子建造专门交给一个叫做Spring的人去帮你做，你只需要专心你的业务逻辑，是不是省心很多，同时这个叫Spring干的又专业又稳定，何乐而不为呢。 从这里我们可以认为Spring是一个超级粘合平台，除了自己提供功能外，还提供粘合其他技术和框架的能力，从而使我们可以更自由的选择到底使用什么技术进行开发。 Spring作用？上面提到业务逻辑的开发，而使用Spring就能帮助我们简化开发。 具体作用： 根据Spring配置文件创建及组装对象之间的依赖关系。 面向切面编程能帮助我们无耦合的实现日志记录，性能统计，安全控制。 非常简单的帮我们管理数据库事务。 提供了与第三方数据访问框架（如Hibernate、JPA）无缝集成，而且自己也提供了一套JDBC访问模板，来方便数据库访问。 提供与第三方Web（如Struts、JSF）框架无缝集成，而且自己也提供了一套Spring MVC框架，来方便web层搭建。 方便的与Java EE（如Java Mail、任务调度）整合，与更多技术整合（比如缓存框架）。 Spring带来的好处在了解Spring的好处之前，先理解以下几个专业名词： 应用程序：是能完成我们所需要功能的成品，比如购物网站、OA系统、ERP系统。 框架：是能完成一定功能的半成品，比如我们可以使用框架进行购物网站开发；框架做一部分功能，我们自己做一部分功能，这样应用程序就创建出来了。而且框架规定了你在开发应用程序时的整体架构，提供了一些基础功能，还规定了类和对象的如何创建、如何协作等，从而简化我们开发，让我们专注于业务逻辑开发。 非侵入式设计：从框架角度可以这样理解，无需继承框架提供的类，这种设计就可以看作是非侵入式设计，如果继承了这些框架类，就是侵入设计，如果以后想更换框架之前写过的代码几乎无法重用，如果非侵入式设计则之前写过的代码仍然可以继续使用。 轻量级&amp;重量级：轻量级是相对于重量级而言的，轻量级一般就是非入侵性的、所依赖的东西非常少、资源占用非常少、部署简单等等，其实就是比较容易使用，而重量级正好相反。 POJO：POJO（Plain Old Java Objects）简单的Java对象，它可以包含业务逻辑或持久化逻辑，但不担当任何特殊角色且不继承或不实现任何其它Java框架的类或接口。 容器：在日常生活中容器就是一种盛放东西的器具，从程序设计角度看就是装对象的的对象，因为存在放入、拿出等操作，所以容器还要管理对象的生命周期。 控制反转：即Inversion of Control，缩写为IoC，控制反转还有一个名字叫做依赖注入（Dependency Injection），就是由容器控制程序之间的关系，而非传统实现中，由程序代码直接操控。 Bean：一般指容器管理对象，在Spring中指Spring IoC容器管理对象。 那么用Spring框架到底有什么好处呢？ 非常轻量级的容器：以集中的、自动化的方式进行应用程序对象创建和装配，负责对象创建和装配，管理对象生命周期，能组合成复杂的应用程序。Spring容器是非侵入式的（不需要依赖任何Spring特定类），而且完全采用POJOs进行开发，使应用程序更容易测试、更容易管理。而且核心JAR包非常小，Spring3.0.5不到1M，而且不需要依赖任何应用服务器，可以部署在任何环境（Java SE或Java EE）。 AOP：AOP是Aspect Oriented Programming的缩写，意思是面向切面编程，提供从另一个角度来考虑程序结构以完善面向对象编程（相对于OOP），即可以通过在编译期间、装载期间或运行期间实现在不修改源代码的情况下给程序动态添加功能的一种技术。通俗点说就是把可重用的功能提取出来，然后将这些通用功能在合适的时候织入到应用程序中；比如安全，日记记录，这些都是通用的功能，我们可以把它们提取出来，然后在程序执行的合适地方织入这些代码并执行它们，从而完成需要的功能并复用了这些功能。 简单的数据库事务管理：在使用数据库的应用程序当中，自己管理数据库事务是一项很让人头疼的事，而且很容易出现错误，Spring支持可插入的事务管理支持，而且无需JEE环境支持，通过Spring管理事务可以把我们从事务管理中解放出来来专注业务逻辑。 JDBC抽象及ORM框架支持：Spring使JDBC更加容易使用；提供DAO（数据访问对象）支持，非常方便集成第三方ORM框架，比如Hibernate等；并且完全支持Spring事务和使用Spring提供的一致的异常体系。 灵活的Web层支持：Spring本身提供一套非常强大的MVC框架，而且可以非常容易的与第三方MVC框架集成，比如Struts等。 简化各种技术集成：提供对Java Mail、任务调度、JMX、JMS、JNDI、EJB、动态语言、远程访问、Web Service等的集成。 Spring结构图 从中可以看到Spring Framework差不多有20个模块组成，这些模块分为核心容器，数据访问/集成，Web，AOP（面向方面的编程），Instrumentation，消息传递和测试，如上图所示。 Core Container模块，包含spring-beans、spring-core、spring-context、spring-expression四个方面。 spring-core和spring-beans：提供了++框架的基础++部分，包括反转控制和依赖注入功能。其中Bean Factory是容器核心，本质是“工厂设计模式”的实现，而且无需编程实现“单例设计模式”，单例完全由容器控制，而且提倡面向接口编程，而非面向实现编程；所有应用程序对象及对象间关系由框架管理，从而真正把你从程序逻辑中把维护对象之间的依赖关系提取出来，所有这些依赖关系都由BeanFactory来维护。 spring-context：这个模块建立在core和bean模块提供坚实的基础上，集成Beans模块功能并添加资源绑定、数据验证、国际化、Java EE支持、容器生命周期、事件传播等；核心接口是ApplicationContext。 spring-expression：提供强大的表达式语言支持，支持访问和修改属性值，方法调用，支持访问及修改数组、容器和索引器，命名变量，支持算数和逻辑运算，支持从Spring容器获取Bean，它也支持列表投影、选择和一般的列表聚合等。 AOP and Instrumentation模块，包含spring-aop、spring-instrument两个方面。 spring-aop：Spring AOP模块提供了符合 AOP Alliance规范的面向方面的编程（aspect-oriented programming）实现，提供比如日志记录、权限控制、性能统计等通用功能和业务逻辑分离的技术，并且能动态的把这些功能添加到需要的代码中；这样各专其职，降低业务逻辑和通用功能的耦合。 spring-instrument：在特定的应用程序服务器中支持类和类加载器的实现，比如Tomcat。 Messaging，从Spring Framework 4开始集成了MessageChannel, MessageHandler等，用于消息传递的基础。 Data Access/Integration，包括了JDBC、ORM、OXM、JMS和事务管理。 事务模块：该模块用于Spring管理事务，只要是Spring管理对象都能得到Spring管理事务的好处，无需在代码中进行事务控制了，而且支持编程和声明性的事物管理。 spring-jdbc： 提供了一个JBDC的样例模板，使用这些模板能消除传统冗长的JDBC编码还有必须的事务控制，而且能享受到Spring管理事务的好处。 spring-orm： 提供与流行的“对象-关系”映射框架的无缝集成，包括Hibernate、JPA、Ibatiss等。而且可以使用Spring事务管理，无需额外控制事务。 spring-oxm： 提供了一个对Object/XML映射实现，将java对象映射成XML数据，或者将XML数据映射成java对象，Object/XML映射实现包括JAXB、Castor、XMLBeans和XStream。 spring-jms： 用于JMS(Java Messaging Service)，提供一套 “消息生产者、消息消费者”模板用于更加简单的使用JMS，JMS用于用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。 Web，包含了spring-web, spring-webmvc, spring-websocket, and spring-webmvc-portlet几个模块。 Spring-web: 提供了基础的web功能。例如多文件上传、集成IoC容器、远程过程访问（RMI、Hessian、Burlap）以及Web Service支持，并提供一个RestTemplate类来提供方便的Restful services访问。 spring-webmvc： 提供了一个Spring MVC Web框架和REST Web服务的实现。Spring的MVC框架提供了领域模型代码和Web表单之间分离，并与Spring框架的所有其他功能集成。 spring-webmvc-portlet： 提供了在Portlet环境中使用MVC实现，并且反映了spring-webmvc模块的功能。 Spring应用场景 典型Web程序应用场景 Spring的声明式事务管理功能让web应用程序完全是事务性的,就像如果你使用EJB容器管理的事务。你所有的自定义的业务逻辑可以通过简单的pojo实现和由Spring的IoC容器。服务包括支持发送电子邮件和web层的独立验证,可以让你选择在哪里执行验证规则。 远程访问应用场景 Spring能非常方便的提供暴露RMI服务，远程访问服务如Hessian、Burlap等，实现非常简单只需通过在Spring中配置相应的地址及需要暴露的服务即可轻松实现。 总结 首先要明确Spring是个什么东西，能帮我们做些什么事情，知道了这些然后做个简单的例子，这样就基本知道怎么使用Spring了。Spring核心是IoC容器，所以一定要透彻理解什么是IoC容器，以及如何配置及使用容器，其他所有技术都是基于容器实现的；理解好IoC后，接下来是面向切面编程，首先还是明确概念，基本配置，最后是实现原理，接下来就是数据库事务管理，其实Spring管理事务是通过面向切面编程实现的，所以基础很重要，IoC容器和面向切面编程搞定后，其余都是基于这俩东西的实现，学起来就更加轻松了。要学好Spring不能急，一定要把基础打牢，基础牢固了，这就是磨刀不误砍柴工。 本文参考地址： 链接：https://www.jianshu.com/p/7b6a070119c7 來源：简书 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java面试宝典2017版---第一篇]]></title>
    <url>%2F2018%2F02%2F12%2F2018%2FJava%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8%E6%91%98%E8%A6%81%2FJava%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[吾爱有三，日，月，卿；日为朝，月为暮，卿为朝朝暮暮。 12018年，从心开始。 1.Java基础1.一个”.java”源文件中是否可以包括多个类（不是内部类）？有什么限制？ 答：可以有多个类，但只能有一个public的类，并且public的类名必须与文件名相一致。 123456789101112131415解析：public class test &#123; public class testC&#123; &#125;&#125;class testA&#123; &#125;class testB&#123; &#125; 这是一个正确的类文件。如果给类testA或者testB加上public则会报错，原因：一个.java源文件中只能有一个public的类（不是内部类）。 内部类：testC为内部类。 2.Java有没有goto? 答：Java中的保留字，现在没有在Java中使用。 1234解析：什么是goto？ goto 是汇编语言的程序控制结构的始祖：“若条件A，则跳到这里；否则跳到那里”。 goto是一条可以在许多计算机编程语言中找到的语句。它是英文单词go和to的组合。当执行这条语句的时候，它将控制流程无条件地转到另一条语句（也叫“跳转”）。 跳转语句需要指明标记，在不同语言中，标记可以是标识符或行号。在机器码级别，goto是一种分支的形式。 Java中并没有使用过goto，但是Java中的break或continue关键字都是goto的形式。 3.说说&amp;和&amp;&amp;的区别 答：首先了解&amp;和&amp;&amp;，它们都可以用作逻辑与的运算符，表示逻辑与（and），当运算符两边的表达式的结果都为true时，整个运算结果才为true，否则，只要有一方为false，则结果为false。 123456789解析： &amp;&amp;：&amp;&amp;还具有短路的功能，即如果第一个表达式为false，则不再计算第二个表达式。 例如： if(str != null &amp;&amp; !str.equals(“”)) 当str为null时，后面的表达式不会执行，所以不会出现NullPointerException，如果将&amp;&amp;改为&amp;，则会抛出NullPointerException异常。 If(x==33 &amp; ++y&gt;0) y会增长，If(x==33 &amp;&amp; ++y&gt;0)不会增长 &amp;：&amp;还可以用作位运算符，当&amp;操作符两边的表达式不是boolean类型时，&amp;表示按位与操作，我们通常使用0x0f来与一个整数进行&amp;运算，来获取该整数的最低4个bit位。 例如： 0x31 &amp; 0x0f的结果为0x01。 &amp;的位运算符原理：0x31 &amp; 0x0f=0x01怎么算的？在这里，0x表示十六进制数，进行运算先转换成二进制数，0x31对应的二进制数是0011 0001；0xOf对应的是0000 1111。&amp;是按位与运算符，若是上下每列全是1那这一列的结果就是1，否则为0；经过计算可得出0000 0001；转化成十六进制就是0x01。 4.在JAVA中如何跳出当前的多重嵌套循环？ 答：在Java中，要想跳出多重循环，可以在外面的循环语句前定义一个标号，然后在里层循环体的代码中使用带有标号的break 语句，即可跳出外层循环。 123456789101112131415161718192021解析： ①.ok: for(int i=0;i&lt;10;i++) &#123; for(int j=0;j&lt;10;j++) &#123; System.out.println(“i=” + i + “,j=” + j); if(j == 5) break ok; &#125; &#125; ②.条件控制：让外层的循环条件表达式的结果可以受到里层循环体代码的控制，例如在**二维数组**中查找到某个数字 //定义二维数组 int arr[][] = &#123;&#123;1,2,3&#125;,&#123;4,5,6,7&#125;,&#123;9&#125;&#125;; boolean found = false; for(int i=0;i&lt;arr.length &amp;&amp; !found;i++) &#123; for(int j=0;j&lt;arr[i].length;j++)&#123; System.out.println(“i=” + i + “,j=” + j); if(arr[i][j] == 5) &#123; found = true; break; &#125; &#125; &#125; 二维数组？二维数组本质上是以数组作为数组元素的数组，即“数组的数组”，类型说明符 数组名[常量表达式][常量表达式]。二维数组又称为矩阵，行列数相等的矩阵称变方阵。对称矩阵a[i][j] = a[j][i]，对角矩阵：n阶方阵主对角线外都是零元素。 5.switch语句能否作用在byte上，能否作用在long上，能否作用在String上? 答：在switch（expr1）中，expr1只能是一个整数表达式或者枚举常量（更大字体），整数表达式可以是int基本类型或Integer包装类型，由于，byte,short,char都可以隐含转换为int，所以，这些类型以及这些类型的包装类型也是可以的。显然，long和String类型都不符合switch的语法规定，并且不能被隐式转换成int类型，所以，它们不能作用于swtich语句中。 12345678910解析： byte a=1; switch (a) &#123; case 1: System.out.println(&quot;switch语句能作用在byte上&quot;); break; default: break; &#125; 控制台输出“switch语句能作用在byte上”，而long和string转换int需要强制转换或者调用其它方法，例如long转int调用intVlaue()方法。 6.short s1 = 1; s1 = s1 + 1;有什么错? short s1 = 1; s1 += 1;有什么错? 答： 对于short s1 = 1; s1 = s1 + 1; 由于s1+1运算时会自动提升表达式的类型，所以结果是int型，再赋值给short类型s1时，编译器将报告需要强制转换类型的错误。 对于short s1 = 1; s1 += 1;由于 += 是java语言规定的运算符，java编译器会对它进行特殊处理，因此可以正确编译。 盘点Java中+=；s1+=1相当于s1=s1+1，等式是先将1转换为s1一样的类型再进行s1+1。也就等价于s1=s1+(s1)1； 7.char型变量中能不能存贮一个中文汉字?为什么? 答：char型变量是用来存储Unicode编码的字符的，unicode编码字符集中包含了汉字，所以，char型变量中当然可以存储汉字啦。不过，如果某个特殊的汉字没有被包含在unicode编码字符集中，那么，这个char型变量中就不能存储这个特殊汉字。补充说明：unicode编码占用两个字节，所以，char类型的变量也是占用两个字节。 1234567891011121314151617181920212223String str= &quot;中&quot;; char x =&apos;中&apos;; byte[] bytes=null; byte[] bytes1=null; try &#123; bytes = str.getBytes(&quot;utf-8&quot;); bytes1 = charToByte(x); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;bytes 大小：&quot;+bytes.length); System.out.println(&quot;bytes1大小：&quot;+bytes1.length); &#125; public static byte[] charToByte(char c) &#123; byte[] b = new byte[2]; b[0] = (byte) ((c &amp; 0xFF00) &gt;&gt; 8); b[1] = (byte) (c &amp; 0xFF); return b; &#125; //运行结果： //bytes 大小：3 //bytes1大小：2 unicode为2个字节（16位）来表示一个字符 8.用最有效率的方法算出2乘以8等於几? 答：2 &lt;&lt; 3 12解析： 因为将一个数左移n位，就相当于乘以了2的n次方，那么，一个数乘以8只要将其左移3位即可，而位运算cpu直接支持的，效率最高，所以，2乘以8等於几的最效率的方法是2 &lt;&lt; 3。 2&lt;&lt;3，直接读作2左移3位，而不是2小于小于3。 9.请设计一个一百亿的计算器首先要明白这道题目的考查点是什么，一是大家首先要对计算机原理的底层细节要清楚、要知道加减法的位运算原理和知道计算机中的算术运算会发生越界的情况，二是要具备一定的面向对象的设计思想。 12345678910111213141516171819202122232425262728293031323334首先，计算机中用固定数量的几个字节来存储的数值，所以计算机中能够表示的数值是有一定的范围的，为了便于讲解和理解，我们先以byte 类型的整数为例，它用1个字节进行存储，表示的最大数值范围为-128到+127。 -1在内存中对应的二进制数据为11111111，如果两个-1相加，不考虑Java运算时的类型提升，运算后会产生进位，二进制结果为1,11111110，由于进位后超过了byte类型的存储空间，所以进位部分被舍弃，即最终的结果为11111110，也就是-2，这正好利用溢位的方式实现了负数的运算。 -128在内存中对应的二进制数据为10000000，如果两个-128相加，不考虑Java运算时的类型提升，运算后会产生进位，二进制结果为1,00000000，由于进位后超过了byte类型的存储空间，所以进位部分被舍弃，即最终的结果为00000000，也就是0，这样的结果显然不是我们期望的，这说明计算机中的算术运算是会发生越界情况的，两个数值的运算结果不能超过计算机中的该类型的数值范围。 由于Java中涉及表达式运算时的类型自动提升，我们无法用byte类型来做演示这种问题和现象的实验，大家可以用下面一个使用整数做实验的例子程序体验一下： int a = Integer.MAX_VALUE; int b = Integer.MAX_VALUE; int sum = a + b; System.out.println(“a=”+a+”,b=”+b+”,sum=”+sum);先不考虑long类型，由于int的正数范围为2的31次方，表示的最大数值约等于2*1000*1000*1000，也就是20亿的大小，所以，要实现一个一百亿的计算器，我们得自己设计一个类可以用于表示很大的整数，并且提供了与另外一个整数进行加减乘除的功能，大概功能如下： （）这个类内部有两个成员变量，一个表示符号，另一个用字节数组表示数值的二进制数 （）有一个构造方法，把一个包含有多位数值的字符串转换到内部的符号和字节数组中 （）提供加减乘除的功能 public class BigInteger&#123; int sign; byte[] val; public Biginteger(String val) &#123; sign = ; val = ; &#125; public BigInteger add(BigInteger other) &#123; &#125; public BigInteger subtract(BigInteger other) &#123; &#125; public BigInteger multiply(BigInteger other)&#123; &#125; public BigInteger divide(BigInteger other)&#123; &#125; &#125; 参看jdk中自带的java.math.BigInteger类的源码 要想写出这个类的完整代码，面试的人也知道谁都不可能在短时间内写出这个类的完整代码的，他要的是你是否有这方面的概念和意识，他最重要的还是考查你的能力，所以，你不要因为自己无法写出完整的最终结果就放弃答这道题，你要做的就是你比别人写得多，证明你比别人强，你有这方面的思想意识就可以了，毕竟别人可能连题目的意思都看不懂，什么都没写，你要敢于答这道题，即使只答了一部分，那也与那些什么都不懂的人区别出来，拉开了距离，算是矮子中的高个，机会当然就属于你了。另外，答案中的框架代码也很重要，体现了一些面向对象设计的功底，特别是其中的方法命名很专业，用的英文单词很精准，这也是能力、经验、专业性、英语水平等多个方面的体现，会给人留下很好的印象，在编程能力和其他方面条件差不多的情况下，英语好除了可以使你获得更多机会外，薪水可以高出一千元。 10.使用final关键字修饰一个变量时，是引用不能变，还是引用的对象不能变？ 答：使用final关键字修饰一个变量时，是指引用变量不能变，引用变量所指向的对象中的内容还是可以改变的。 1234567891011121314解析： 例如，对于如下语句： final StringBuffer a=new StringBuffer(&quot;immutable&quot;); 执行如下语句将报告编译期错误： a=new StringBuffer(&quot;&quot;); 但是，执行如下语句则可以通过编译： a.append(&quot; broken!&quot;); 有人在定义方法的参数时，可能想采用如下形式来阻止方法内部修改传进来的参数对象： public void method(final StringBuffer param) &#123; &#125; 实际上，这是办不到的，在该方法内部仍然可以增加如下代码来修改参数对象： param.append(&quot;a&quot;); final在Java中是一个修饰词。修饰基础数据成员是final的主要用途，成员被修饰为常量，意味着成员只能被赋值一次便不可修改。 在Java中，我们无法让对象被修饰为final，而只能修饰对象的引用，这意味着即使你写public final A a = new A(); 事实上a指向的对象的数据依然可以被修改，不能修改的是a本身的引用值，即你不能再对a进行重赋值。同样的情况出现在数组中，比如public final int[] a = {1, 2, 3, 4, 5}，事实上a中的数值是可修改的，即可以写a[0] = 3。据目前了解，java中数组内的数据是无法修饰为不可修改的，而C/C++可以。 修饰方法的final和C/C++中修饰成员对象的const大不相同。首先，修饰方法的final含义不是“不可修改”，而是指该方法不可被继承成员重新定义。（注意，这里所说的不能被重新定义，并不是指子类一定不能定义同名方法，如果父类的方法是私有类型，子类是允许定义该方法的，这里指的不能重新定义是指不能通过改写方法来使得方法重写的多态性得以实现，如不希望A a = new B(); a.f();这样的重写方法情况出现）`public class A {// final方法fpublic final void f() {System.out.println(&quot;类A中的final方法f被调用了&quot;); }}public class B extends A { // 编译错误！父类的f方法是final类型，不可重写！ //! public void f() { //! System.out.println(“类B中的方法f被调用了”); //! }} `此外，当一个方法被修饰为final方法时，意味着编译器可能将该方法用内联(inline)方式载入，所谓内联方式，是指编译器不用像平常调用函数那样的方式来调用方法，而是直接将方法内的代码通过一定的修改后copy到原代码中。这样可以让代码执行的更快（因为省略了调用函数的开销），比如在int[] arr = new int[3]调用arr.length()等。另一方面，私有方法也被编译器隐式修饰为final，这意味着private final void f()和private void f()并无区别。 当一个类被修饰为final时，它的含义很明确，就是不允许该类被继承，也就是说，该类“绝后”了，任何继承它的操作都会以编译错误告终。这也凸显出Java用final而不用const作为标识符的理由。]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>Java面试宝典</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[int和integer的区别与用法]]></title>
    <url>%2F2018%2F02%2F12%2F2018%2F%E9%9A%8F%E6%89%8B%E8%AE%B0%2FJava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%9B%98%E7%82%B9%2F</url>
    <content type="text"><![CDATA[int 与 integer基本使用对比int int 是**基本类型**，直接存数值，进行初始化时int类的变量初始为0。 integer integer是对象，用一个引用指向这个对象，Integer的变量则初始化为null。 开发项目时Integer 与int 什么时候用？什么时候用Integer : 如果该属性所对应的数据库的字段是主键或者是外键时，用Integer；因为Integer的默认值为null，数据库的主键或者外键不能为空，但是可以为null 什么时候用int : 如果表示数量用int，因为int的默认值为0，它不能为null或者空 知识在于积累实践出真知 end]]></content>
      <categories>
        <category>随手记</category>
      </categories>
      <tags>
        <tag>Java随手记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[this和super的用法总结]]></title>
    <url>%2F2018%2F02%2F10%2F2018%2F%E9%9A%8F%E6%89%8B%E8%AE%B0%2FJava%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[这几天看到类在继承时会用到this和super，这里就做一点总结。 thisthis是自身的一个对象，代表对象本身，可以理解为：指向对象本身的一个指针。 this的三种用法： [普通的直接引用] [形参与成员名字重名，用this来区分：]1234567891011121314151617class Person &#123; private int age = 10; public Person()&#123; System.out.println(&quot;初始化年龄：&quot;+age);&#125; public int GetAge(int age)&#123; this.age = age; return this.age; &#125;&#125; public class test1 &#123; public static void main(String[] args) &#123; Person Harry = new Person(); System.out.println(&quot;Harry&apos;s age is &quot;+Harry.GetAge(12)); &#125;&#125; 运行结果： 初始化年龄：10 Harry’s age is 12 可以看到，这里age是GetAge成员方法的形参，this.age是Person类的成员变量。 [引用构造函数] supersuper可以理解为是指向自己超（父）类对象的一个指针，而这个超类指的是离自己最近的一个父类。 super的三种用法： [普通的直接引用] 与this类似，super相当于是指向当前对象的父类，这样就可以用super.xxx来引用父类的成员。 [子类中的成员变量或方法与父类中的成员变量或方法同名] 123456789101112131415161718192021class Country &#123; String name; void value() &#123; name = &quot;China&quot;; &#125;&#125; class City extends Country &#123; String name; void value() &#123; name = &quot;Shanghai&quot;; super.value(); //调用父类的方法 System.out.println(name); System.out.println(super.name); &#125; public static void main(String[] args) &#123; City c=new City(); c.value(); &#125;&#125; 运行结果： Shanghai China 可以看到，这里既调用了父类的方法，也调用了父类的变量。若不调用父类方法value()，只调用父类变量name的话，则父类name值为默认值null。 [引用构造函数] super（参数）：调用父类中的某一个构造函数（应该为构造函数中的第一条语句）。 this（参数）：调用本类中另一种形式的构造函数（应该为构造函数中的第一条语句）。 123456789101112131415161718192021222324252627282930313233343536class Person &#123; public static void prt(String s) &#123; System.out.println(s); &#125; Person() &#123; prt(&quot;父类·无参数构造方法： &quot;+&quot;A Person.&quot;); &#125;//构造方法(1) Person(String name) &#123; prt(&quot;父类·含一个参数的构造方法： &quot;+&quot;A person&apos;s name is &quot; + name); &#125;//构造方法(2) &#125; public class Chinese extends Person &#123; Chinese() &#123; super(); // 调用父类构造方法（1） prt(&quot;子类·调用父类”无参数构造方法“： &quot;+&quot;A chinese coder.&quot;); &#125; Chinese(String name) &#123; super(name);// 调用父类具有相同形参的构造方法（2） prt(&quot;子类·调用父类”含一个参数的构造方法“： &quot;+&quot;his name is &quot; + name); &#125; Chinese(String name, int age) &#123; this(name);// 调用具有相同形参的构造方法（3） prt(&quot;子类：调用子类具有相同形参的构造方法：his age is &quot; + age); &#125; public static void main(String[] args) &#123; Chinese cn = new Chinese(); cn = new Chinese(&quot;codersai&quot;); cn = new Chinese(&quot;codersai&quot;, 18); &#125; &#125; 运行结果： 父类·无参数构造方法： A Person. 子类·调用父类”无参数构造方法“： A chinese coder. 父类·含一个参数的构造方法： A person’s name is codersai 子类·调用父类”含一个参数的构造方法“： his name is codersai 父类·含一个参数的构造方法： A person’s name is codersai 子类·调用父类”含一个参数的构造方法“： his name is codersai 子类：调用子类具有相同形参的构造方法：his age is 18 从本例可以看到，可以用super和this分别调用父类的构造方法和本类中其他形式的构造方法。 例子中Chinese类第三种构造方法调用的是本类中第二种构造方法，而第二种构造方法是调用父类的，因此也要先调用父类的构造方法，再调用本类中第二种，最后是重写第三种构造方法。 super和this的异同： super（参数）：调用基类中的某一个构造函数（应该为构造函数中的第一条语句） this（参数）：调用本类中另一种形成的构造函数（应该为构造函数中的第一条语句） super: 它引用当前对象的直接父类中的成员（用来访问直接父类中被隐藏的父类中成员数据或函数，基类与派生类中有相同成员定义时如：super.变量名 super.成员函数据名（实参） this：它代表当前对象名（在程序中易产生二义性之处，应使用this来指明当前对象；如果函数的形参与类中的成员数据同名，这时需用this来指明成员变量名） 调用super()必须写在子类构造方法的第一行，否则编译不通过。每个子类构造方法的第一条语句，都是隐含地调用super()，如果父类没有这种形式的构造函数，那么在编译的时候就会报错。 super()和this()类似,区别是，super()从子类中调用父类的构造方法，this()在同一类内调用其它方法。 super()和this()均需放在构造方法内第一行。 尽管可以用this调用一个构造器，但却不能调用两个。 this和super不能同时出现在一个构造函数里面，因为this必然会调用其它的构造函数，其它的构造函数必然也会有super语句的存在，所以在同一个构造函数里面有相同的语句，就失去了语句的意义，编译器也不会通过。 this()和super()都指的是对象，所以，均不可以在static环境中使用。包括：static变量,static方法，static语句块。 从本质上讲，this是一个指向本对象的指针,然而super是一个Java关键字。 end 知识在于积累]]></content>
      <categories>
        <category>随手记</category>
      </categories>
      <tags>
        <tag>Java随手记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[需要了解的基础知识]]></title>
    <url>%2F2018%2F02%2F08%2F2018%2FJava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB%2FJava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E2%91%A0%2F</url>
    <content type="text"><![CDATA[Jre 和 Jdk 的区别?–JRE： （Java Runtime Environment），java 运行环境。包括Java虚拟机(JVM Java Virtual Machine)和 Java 程序所需的核心类库等，如果想要运行一个开发好的 Java 程序，计算机中只需要安装 JRE 即可。–JDK：（Java Development Kit Java） 开发工具包。JDK 是提供给 Java 开发人员使用的，其中包含了 java 的开发工具，也包括了 JRE。所以安装了 JDK，就不用在单独安装 JRE 了。其中的开发工具：编译工具(javac.exe) 打包工具(jar.exe) 等简单而言： 使用 JDK 开发完成的 Java 程序，交给 JRE 去运行。 1我的总结：必须熟练的记忆， 核心类库，开发工具！ Java 虚拟机 JVMJava Virtual Machine ，简称 JVM; 它是运行所有 Java 程序的抽象计算机,是 Java 语言的运行环境，它是 Java 最具吸引力的特性之一，JVM 读取并处理编译过的与平台无关的字节码(class)文件。Java 编译器针对 JVM 产生 class 文件，因此是独立于平台的。Java 解释器负责将 JVM 的代码在特定的平台上运行。Java 虚拟机是不跨平台的. Java 程序运行机制 .java文件—&gt;javac.exe编译—&gt;.class文件—&gt;java.exe运行—&gt;结果 编译: javac 文件名.文件后缀名运行: java 类名 1我的总结：Java 程序的组成：Java 源文件，字节码文件。 Java 成员变量和局部变量局部变量： 不是声明在类体括号里面的变量； 局部变量使用前必须初始化值; 局部变量没有默认初始化值; 局部变量的作用域是从定义开始到定义它的代码块结束; 成员变量: 在方法体外,类体内声明的变量，又称字段(Field)或全局变量；（其实 Java 中没有全 局变量，由于 Java是面向对象语言，所有变量都是类成员） 成员变量的作用域是整个类中; 1我的总结：注意成员变量和局部变量的区别 基本数据类型 在数据类型中，最常用也是最基础的数据类型，被称作基本数据类型。可以使用这些类型的值来代表一些简单的状态。 基本数据类型： 整数型： byte(字节型)，short(短整型)，int(整型)，long(长整型) 小数型： float(单精度浮点型)，double(双精度浮点型) 字符型： char(字符型) 布尔型：boolean(布尔型)]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[杂谈]]></title>
    <url>%2F2018%2F02%2F08%2F2018%2F02-08%2F%E6%9D%82%E8%B0%88%2F</url>
    <content type="text"><![CDATA[网易云音乐的那些事—“我们浪费掉了太多的青春，那是一段如此自以为是、又如此狼狈不堪的青春岁月，有欢笑，也有泪水；有朝气，也有颓废；有甜蜜，也有荒唐；有自信，也有迷茫。我们敏感，我们偏执，我们顽固到底地故作坚强；我们轻易的伤害别人，也轻易的被别人所伤，我们追逐于颓废的快乐，陶醉于寂寞的美丽…”——叶京 from -Auld Lang Syne—结婚的时候，她是伴娘。进入礼堂的时候和我站在一起，看着我将迎娶的新娘，她悄悄对我说了一句话让我红了眼眶。“我们终于一起步入结婚殿堂。” from -Beautiful In White (Demo)—当你喜欢一个优秀的人时，你会觉得自己千疮百孔。 from -遇见—最好的时代总在过去 from -初恋情人]]></content>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工具篇------FTPServer]]></title>
    <url>%2F2018%2F02%2F08%2F2018%2F%E4%BC%81%E4%B8%9A%E7%BA%A7%E9%A1%B9%E7%9B%AE%2F%E5%B7%A5%E5%85%B7%E7%AF%87-FTPServer%2F</url>
    <content type="text"><![CDATA[—轻量级FTP服务器简介轻量级FTP服务器软件,没有复杂的设置,没有复杂的操作,傻瓜都能搭建属于自己的FTP服务器! 下载 ftp server]]></content>
      <categories>
        <category>工具篇</category>
      </categories>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开启我的博客之旅]]></title>
    <url>%2F2018%2F02%2F07%2F2018%2F%E5%BC%80%E7%AF%87%2Fhello-blog%2F</url>
    <content type="text"><![CDATA[Welcome to Coder LiXinHua’s Blog!This is my first blog.Thank for you coming,and thank for your support.They are the energy to encourage me to move forward.From now on, I will update my blog regularly.I will record my learning knowledge here. Truth优秀的人，不是不合群，而是他们合群的人里面没有你]]></content>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
</search>
